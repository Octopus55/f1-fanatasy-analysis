<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>report – F1-race-predictions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">F1-race-predictions</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../honors/outcomes.html"> 
<span class="menu-text">Predictions</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#other-questions" id="toc-other-questions" class="nav-link active" data-scroll-target="#other-questions">Other Questions?</a>
  <ul class="collapse">
  <li><a href="#experimental-results" id="toc-experimental-results" class="nav-link" data-scroll-target="#experimental-results">Experimental Results</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">STAT4255 Final Project: F1 Race Podium Forecasting</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The Formula 1 dataset we used has 72 features where each observation represents the results of 1 driver in a specific race. For example, if a race has 20 participating drivers, then there will be 20 records associated with that specific race. Many of the features are related to characteristics of a track such as the average speed, the maximum speed, the longest staight length, the number of corners, etc. Other features tell information about the track conditions such as temperature, humidity, precipitation, and windspeed. Lastly, some of the most important features have to do with how a driver or team has performed in previous races. These features convey performance through how many points or wins a driver or team has accumulated in a span of prior races.</p>
<p>The main question we wanted to tackle was determining what training size is best for predicting podium (top 3) finishes for each driver. To accomplish this we had to fit models for various training sizes (also called windows) of prior races and then compare how well they performed in classifying an observation as a podium finish or not in the next race. This question was especially interesting because in previous analyses, overfitting to the training data was a common source of error. F1 teams are capable of significantly upgrading their cars from race to race which can be difficult for models to adapt to. The aim of this question was to pinpoint the window size for which the training data is most most relevant. A model with a window size of just a handful of races (say 2 or 3) may not have enough information to make accurate predictions and put too much weight in a small sample of results. On the other hand, a model with a large window size (15 or 20 races) could be basing its predictions off of noisy data that is no longer representative of the current competition. We wanted to know what window size is the “sweet spot” for making the most accurate predictions.</p>
<section id="other-questions" class="level1">
<h1>Other Questions?</h1>
<p>There were many approaches that we considered in attempting to make the most accurate predictions.</p>
<p>The first step of the project was creating a function that could use an approach and return the results for each window size up to a specified value of n.&nbsp;This function was a big success and laid the foundation for comparing different variable selection and modeling processes. The way the function works is that it creates a model for every race and every window size (n). It then makes predictions for every race using its respective model and summarizes the performance metrics for each value of n at the end. The predictions are classified by assigning the drivers with the 3 highest probabilities derived from the model to the podium class and the rest to the non-podium class. The metric that we thought was most indicative of performance was the average F1 score. F1 score is calculated by <span class="math inline">\(\frac{2*P*R}{P+R}\)</span> where P is the precision (the accuracy of podium predictions) and R is recall (the true positive rate). An F1 score greater than 0.5 indicates that the model is better than random guessing. F1 score was better than using accuracy since accuracy would naturally be pretty high for every model with the worse case of getting 14/17 non-podium predictions correct.</p>
<p>Once we had the ability to see how F1 score varied for each value of n we immediately saw a trend starting to form. As n increased, F1 score would generally increase up to a certain point. After reaching that point, larger values of n generally had same or lower F1 scores. These were encouraging results as it appeared there was a “sweet spot” value of n.</p>
<p>The next step was determining what type of model and feature selection was the best.</p>
<p>The first type of model that we fit was a logistic regression model with manually selected features. This approach did not yield high F1 scores. One issue that we ran into was encoding interaction terms.</p>
<p>We also experimented with decision trees. The decision trees showed some promising results and could generate high F1 scores for individual races. Unfortunately, the decision trees did not quite have the functionality we were looking for with regards to dealing with interactions. The trees were also prone to overfitting.</p>
<p>At this point we wanted to try out automatic feature selection. This was done using xg_boost. The thought here was also that the models could benefit from interact features implemented by xg_boost. This approach however also did not perform very well. It seemed that xg_boost was not selecting the best combination of features.</p>
<p>One aspect that allowed us to observe higher F1 scores was implementing sinthetic minority over-sampling or SMOTE. To this point our classification had been imbalanced. Only 3/20 or 15% of results were positive (podium) classifications. This means that our models are biased toward negative (non-podium) classifications. By using SMOTE, the minority (positive) classifications are randomly resampled from the minority distribution until the number of positive and negative classifications are more balanced. This balanced classification technique improved performance by 15-20% in F1 score.</p>
<p>This led us to our final approach which was using an xg boosting regressor and conducting manual forward selection. The manual selection process consisted of picking features one at a time, checking if they improved…</p>
<!--
Logistic regression
Decision trees - overfitting

SMOTE - imbalance classification, only 15% of results were actual positive classification, biased toward negative classifications, improved performance by 15-20% in F1 score
xg_boost - automatically implements interaction features

automatic feature selection did not work well (from xg_boost)

manual forward selection - picking a few features, adding random features until we could no longer improve performance

Final:
manual selection
xg boosting regressor selecting top 3 probabilities 

-->
<section id="experimental-results" class="level2">
<h2 class="anchored" data-anchor-id="experimental-results">Experimental Results</h2>
<p><strong>Parameterizing the training data window size</strong></p>
<p>In order to validate our approach, we performed several experiments over the data. First, we thoroughly investigated the performance of the XGBoost model over 2024 F1 race data (races spanning from Bahrain 2024 to Qatar 2024) for a fixed selection of features, namely:</p>
<ul>
<li>The proportion of points in the standings belonging to each driver before a given race</li>
<li>Whether or not a driver drove for McLaren</li>
<li>Whether or not a driver drove for RedBull</li>
<li>Whether or not a driver was Charles Leclerc</li>
<li>The maximum track speed for a given circuit</li>
<li>The number of previous constructor wins</li>
<li>The number of podiums scored by a given driver over the previous 2, 3, and 4 races</li>
</ul>
<p>Using these features, we fitted XGBoost models over data window sizes of 2 to 11 rounds. Because XGBoost’s fitting algorithm is stochastic, we needed to perform multiple runs to generate a confidence interval over the true F1 score of the model on the data. From a series of initial runs, we determined that 7 races was the strongest data window size, and then ran 15 iterations to estimate the standard errors of this estimate. Using CLT, we can approximate the distribution of mean F1 scores for training on 7 races of data by a normal distribution (as long as the sample size is sufficiently large).</p>
<p>Namely, for training an XGBoosing model over data from the previous 7 races, we observe an average F1 score of 0.536 over the next race in sequence (for all races from Bahrain to Qatar). The standard deviation of average F1 scores achieved by these models was 0.0072, and so a 95% confidence interval for an estimate of the average F1 score achieved by XGBoost trainged over the prior 7 races of data in 2024 was</p>
<p><span class="math display">\[
[0.5224, 0.5506]
\]</span></p>
<p>This is a nice bound, since it means that our XGBoost model typically performs well for race data windows of size 7 (better than random guessing). To see that seven is the best choice, the results for window sizes from 2 to 11 can be seen below:</p>
<div id="312dff50" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> pd.read_csv(<span class="st">"../code/experiments/results_window_sample.csv"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>res</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">n</th>
<th data-quarto-table-cell-role="th">Accuracy</th>
<th data-quarto-table-cell-role="th">F1 Score</th>
<th data-quarto-table-cell-role="th">Acc_Max</th>
<th data-quarto-table-cell-role="th">Acc_Min</th>
<th data-quarto-table-cell-role="th">F1_Max</th>
<th data-quarto-table-cell-role="th">F1_Min</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2.0</td>
<td>0.837594</td>
<td>0.460317</td>
<td>1.0</td>
<td>0.700000</td>
<td>1.000000</td>
<td>0.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>3.0</td>
<td>0.842356</td>
<td>0.476190</td>
<td>1.0</td>
<td>0.700000</td>
<td>1.000000</td>
<td>0.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>4.0</td>
<td>0.870927</td>
<td>0.571429</td>
<td>1.0</td>
<td>0.700000</td>
<td>1.000000</td>
<td>0.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>5.0</td>
<td>0.856642</td>
<td>0.523810</td>
<td>1.0</td>
<td>0.789474</td>
<td>1.000000</td>
<td>0.333333</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>6.0</td>
<td>0.866416</td>
<td>0.555556</td>
<td>1.0</td>
<td>0.800000</td>
<td>1.000000</td>
<td>0.333333</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>7.0</td>
<td>0.856642</td>
<td>0.523810</td>
<td>0.9</td>
<td>0.789474</td>
<td>0.666667</td>
<td>0.333333</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>8.0</td>
<td>0.847118</td>
<td>0.492063</td>
<td>1.0</td>
<td>0.789474</td>
<td>1.000000</td>
<td>0.333333</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>9.0</td>
<td>0.837594</td>
<td>0.460317</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>10.0</td>
<td>0.832832</td>
<td>0.444444</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>11.0</td>
<td>0.813784</td>
<td>0.380952</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">10</td>
<td>12.0</td>
<td>0.823308</td>
<td>0.412698</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.000000</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<!--fill in when experiment is finished-->
<p><strong>The utility of track features</strong></p>
<p>On their own, track features are not explicitly useful. The reason for this is that for a given track the track features will be the same for all drivers. As such, if we do not identify the drivers in question, the podium outcomes will be randomly associated with the track features themselves. Thus, we include the driver and constructor information to interact with these variables to achieve improved performance outcomes.</p>
<p>Namely, we consider McLaren and Red Bull as teams and Charles Leclerc as a individual driver for interaction with track features. To determine if these features make a meaningful performance contribution, we compare baseline models which do and do not include track features. Unfortunately, we find that often times including track features actually diminished performance on the whole. Perhaps the reason for this was that different track features are differentially useful across a given race season, and so the average F1 score fitted on models for features that are not useful over all possible windows adds unecessary noise and diminishes performance.</p>
<p><strong>The utility of scaled point distributions</strong></p>
<p>To determine if scaling the point distribution was useful or not, we compared the performance of XGboost models fitted only on raw previous driver point totals and scaled previous driver point totals (driver scaled points = driver total points / number of points awarded to all drivers).</p>
<p>Below you can see the comparative performance of XGboost models trained over data from 2 to 9 of the previous races on the next race in sequence when scaled and unscaled driver point totals are given:</p>
<p><strong><em>Raw (Unscaled) point totals</em></strong></p>
<div id="2fcdf976" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>unscaled_pts <span class="op">=</span> pd.read_csv(<span class="st">"../code/experiments/un-scaled_points_sample.csv"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>unscaled_pts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">n</th>
<th data-quarto-table-cell-role="th">Accuracy</th>
<th data-quarto-table-cell-role="th">F1 Score</th>
<th data-quarto-table-cell-role="th">Acc_Max</th>
<th data-quarto-table-cell-role="th">Acc_Min</th>
<th data-quarto-table-cell-role="th">F1_Max</th>
<th data-quarto-table-cell-role="th">F1_Min</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2.0</td>
<td>0.775439</td>
<td>0.253968</td>
<td>0.9</td>
<td>0.684211</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>3.0</td>
<td>0.785213</td>
<td>0.285714</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>4.0</td>
<td>0.794987</td>
<td>0.317460</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>5.0</td>
<td>0.799749</td>
<td>0.333333</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>6.0</td>
<td>0.799499</td>
<td>0.333333</td>
<td>1.0</td>
<td>0.700000</td>
<td>1.000000</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>7.0</td>
<td>0.785213</td>
<td>0.285714</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>8.0</td>
<td>0.780702</td>
<td>0.269841</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>9.0</td>
<td>0.771178</td>
<td>0.238095</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>10.0</td>
<td>0.780702</td>
<td>0.269841</td>
<td>0.9</td>
<td>0.700000</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p><strong><em>Scaled point totals</em></strong></p>
<div id="7cb3dfa3" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>scaled_pts <span class="op">=</span> pd.read_csv(<span class="st">"../code/experiments/scaled_points_sample.csv"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>scaled_pts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">n</th>
<th data-quarto-table-cell-role="th">Accuracy</th>
<th data-quarto-table-cell-role="th">F1 Score</th>
<th data-quarto-table-cell-role="th">Acc_Max</th>
<th data-quarto-table-cell-role="th">Acc_Min</th>
<th data-quarto-table-cell-role="th">F1_Max</th>
<th data-quarto-table-cell-role="th">F1_Min</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2.0</td>
<td>0.794737</td>
<td>0.317460</td>
<td>0.9</td>
<td>0.7</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>3.0</td>
<td>0.813784</td>
<td>0.380952</td>
<td>0.9</td>
<td>0.7</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>4.0</td>
<td>0.818546</td>
<td>0.396825</td>
<td>0.9</td>
<td>0.7</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>5.0</td>
<td>0.813784</td>
<td>0.380952</td>
<td>0.9</td>
<td>0.7</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>6.0</td>
<td>0.809023</td>
<td>0.365079</td>
<td>1.0</td>
<td>0.7</td>
<td>1.000000</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>7.0</td>
<td>0.813784</td>
<td>0.380952</td>
<td>0.9</td>
<td>0.7</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>8.0</td>
<td>0.828070</td>
<td>0.428571</td>
<td>0.9</td>
<td>0.7</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>9.0</td>
<td>0.799499</td>
<td>0.333333</td>
<td>0.9</td>
<td>0.7</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>10.0</td>
<td>0.823308</td>
<td>0.412698</td>
<td>0.9</td>
<td>0.7</td>
<td>0.666667</td>
<td>0.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>As you can see, F1 scores improve substantially when using a scaled point distribution, indicating that this change was predictively beneficial.</p>
<!-- 
Include discussion of future work. 
-->


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>